<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>yuanyang5917.github.io/</title>
   
   <link>http://yuanyang5917.github.io/</link>
   <description>——LuckyTurbo</description>
   <language>en-uk</language>
   <managingEditor> LuckyTurbo</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Android内存分析之MAT</title>
	  <link>//memory-analyzer-tool</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-04-23T00:00:00+08:00</pubDate>
	  <guid>//memory-analyzer-tool</guid>
	  <description><![CDATA[
	     <p>　　面试中经常会问到内存优化，我们在开发过程中也多少会遇到OOM的问题，根据大牛们的博客，记录下我的学习思路</p>

<h1 id="oom">一、为何会OOM？</h1>

<h3 id="andoridiphoneiphone6ram1gandroidoom">1. 一直以来Andorid手机的内存都比iPhone(iPhone6RAM1G)大的多，Android却经常出现OOM，这是为何？</h3>

<p>　 这个是因为Android系统对dalvik的vm heapsize 作了硬性限制，当java进程申请的java空间超过阀值时，就会抛出OOM异常(这个阀值可以是48M、24M、16M等，视机型而定)，可以通过adb shell getprop ｜ grep dalvik.vm.heapgrowthlimit查看此值。(我的一加2 Android6.0.1已经达到了256M)</p>

<p>　 也就是说，程序发生OOM并不表示RAM不足，而是因为程序申请的java heap对象超过了dalvik.vm.heapgrowthlimit。也就是说，在RAM充足的情况下，也可能发生OOM</p>

<p>　 这样的设计似乎有些不合理，但是Google为什么这样做呢？这样设计的目的是为了让Android系统能同时让比较多的进程常驻内存，这样程序启动时就不用每次都重新加载到内存，能够给用户更快的响应。迫使每个应用程序使用较小的内存，移动设备非常有限的RAM就能使比较多的app常驻其中。</p>

<h3 id="heapsize">2. 大型游戏如何在较小的heapsize上运行？</h3>

<ul>
  <li>
    <p>创建子进程</p>

    <p>创建一个新的进程，那么我们就可以把一些对象分配到新进程的heap上了，从而达到一个应用程序使用更多的内存的目的，当然，创建子进程会增加系统开销，而且并不是所有应用程序都适合这样做，视需求而定。</p>

    <p>创建子进程的方法：使用android:process标签</p>
  </li>
  <li>
    <p>使用jni在native heap上申请空间（推荐使用）</p>

    <p>nativeheap的增长并不受dalvik vm heapsize的限制，从图6可以看出这一点，它的native heap size已经远远超过了dalvik heap size的限制。</p>

    <p>只要RAM有剩余空间，程序员可以一直在native heap上申请空间，当然如果 RAM快耗尽，memory killer会杀进程释放RAM。大家使用一些软件时，有时候会闪退，就可能是软件在native层申请了比较多的内存导致的。比如，我(余龙飞)就碰到过UC web在浏览内容比较多的网页时闪退，原因就是其native heap增长到比较大的值，占用了大量的RAM，被memory killer杀掉了。(Fresco使用的就是这种方式)</p>
  </li>
  <li>
    <p>使用显存（操作系统预留RAM的一部分作为显存）</p>

    <p>使用OpenGL textures等API，texture memory不受dalvik vm heapsize限制，这个我没有实践过。再比如Android中GraphicBufferAllocator申请的内存就是显存。</p>
  </li>
</ul>

<h3 id="androidnative-heapjava-heap">3. Android内存究竟如何?(native heap、java heap)</h3>

<ul>
  <li>
    <p>进程的地址空间</p>

    <p>在32位操作系统中(Native Process)，进程的地址空间为0到4GB：</p>

    <p><img src="http://img.blog.csdn.net/20130513154042627" alt="图一" /></p>

    <ol>
      <li>kernel space(内河空间)：这些地址用户代码不能读也不能写</li>
      <li>Memory Mapping Segment(内存映射)：段文件映射（包括动态库）和匿名映射。</li>
      <li>Stack：（进栈和出栈）由操作系统控制，其中主要存储函数地址、函数参数、局部变量等等，所以Stack空间不需要很大，一般为几MB大小。</li>
      <li>Heap：空间的使用由程序员控制，程序员可以使用malloc、new、free、delete等函数调用来操作这片地址空间。Heap为程序完成各种复杂任务提供内存空间，所以空间比较大，一般为几百MB到几GB。正是因为Heap空间由程序员管理，所以容易出现使用不当导致严重问题。</li>
    </ol>
  </li>
  <li>
    <p>Android中的进程</p>

    <ol>
      <li>
        <p>native进程：采用C/C++实现，不包含dalvik实例的linux进程，/system/bin/目录下面的程序文件运行后都是以native进程形式存在的。如下图/system/bin/surfaceflinger、/system/bin/rild、procrank等就是native进程。</p>
      </li>
      <li>
        <p>java进程：实例化了dalvik虚拟机实例的linux进程，进程的入口main函数为java函数。dalvik虚拟机实例的宿主进程是fork()系统调用创建的linux进程，所以每一个android上的java进程实际上就是一个linux进程，只是进程中多了一个dalvik虚拟机实例。因此，java进程的内存分配比native进程复杂。如图3，Android系统中的应用程序基本都是java进程，如桌面、电话、联系人、状态栏等等。
　<img src="http://img.blog.csdn.net/20130513155151825" alt="这里写图片描述" />
　</p>
      </li>
    </ol>
  </li>
  <li>
    <p>Android中进程的堆内存</p>
  </li>
</ul>

 	    第一张图和下面这张图分别介绍了native process和java process的结构，这个是我们需要深刻理解的，进程空间中的heap空间是我们需要重点关注的。heap空间完全由程序员控制，我们使用的malloc、C++ new和java new所申请的空间都是heap空间， C/C++申请的内存空间在native heap中，而java申请的内存空间则在dalvik heap中。

<p><img src="http://img.blog.csdn.net/20130513155252901" alt="这里写图片描述" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>    注：Java中的code segment，data segment，heap，stack
    stack(栈)：对象引用都是在栈里的，相当于C/C++的指针
    heap(堆)：new出来的对象实例才是在堆里
    data segment：一般存放常量和静态常量
    code segment：方法，函数什么的都是放在code segment
</code></pre>
</div>

<ul>
  <li>Bitmap分配在native heap还是dalvik heap上？</li>
</ul>

<p>　<strong>3.0后是分配在dalvik heap上，和3.x之前是分配在native heap</strong></p>

<ul>
  <li>
    <ol>
      <li>以上主要来自：现任支付宝大神余龙飞著作——<strong><a href="http://blog.csdn.net/gemmem/article/details/8920039">Android进程的内存管理分析</a></strong></li>
    </ol>
  </li>
</ul>

<h1 id="mat">二、内存分析之MAT</h1>

<h3 id="section">1. 谷歌提供了几种内存检测工具：</h3>

<ul>
  <li>Memory Monitor:内存监视器 
<img src="http://img.blog.csdn.net/20160428014853422" alt="这里写图片描述" /></li>
  <li>Heap Viewer:堆查看器
<img src="http://img.blog.csdn.net/20160428015014728" alt="这里写图片描述" />
<img src="http://img.blog.csdn.net/20160428015028213" alt="这里写图片描述" /></li>
  <li>Allocation Tracker:分配追踪器
<img src="http://img.blog.csdn.net/20160428014732467" alt="这里写图片描述" /></li>
  <li>
    <p>Investigating Your RAM Usage：调查您的RAM使用</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  通过Log输出的GC命令来判断：
	
  GC_CONCURRENT：heap快满了
  GC_FOR_MALLOC：因为你的应用程序试图分配内存时，你已经充分引起GC堆，所以系统必须停止你的应用和回收内存。
  GC_HPROF_DUMP_HEAP：GC发生时，你要创建的请求HPROF文件来分析你的堆。
  GC_EXPLICIT：一个明确的GC，当收到调用gc()时出现，应该尽量避免手动调用，而是相信GC会自动清理
  GC_EXTERNAL_ALLOC：只会在API10以及以下才会出现
	

  GC的原因：
  Concurrent：不会暂停应用线程，在后台运行，不会影响内存分配
  Alloc：GC是因为你的应用程序试图分配内存时，你heapwas已满。在这种情况下，垃圾收集发生在分配线程。
  Explicit：手动调用gc()，我们应该避免手动调用，我们要相信GC，手动调用会影响线程分配以及没必要的cpu周期，还可能导致其他线程的抢占。
  NativeAlloc：native内存的回收，主要来自人为造成的native内存压力，例如：Bitmap、渲染脚本分配的对象
  CollectorTransition：.....由于用到的太少，后面的就不再详述
</code></pre>
    </div>
  </li>
</ul>

<h3 id="section-1">2. 触发内存泄漏</h3>

<ul>
  <li>多次切换屏幕的横纵，在Activity不同状态旋转屏幕，然后再返回。旋转设备往往会导致应用程序的Activity、Context、或View对象泄漏，因为系统中重新创建活动，如果程序中其他地方拥有这些对象的引用，系统无法回收。</li>
  <li>多个应用之间切换，在Activity不同的状态下切换（导航至主屏幕，然后返回到您的应用程序）。</li>
</ul>

<h3 id="section-2">3. 怎样的内存是健康的？</h3>

<ul>
  <li><code class="highlighter-rouge">内存使用率低，使用率稳定(波动小)</code></li>
  <li>没有正在使用的对象，要<code class="highlighter-rouge">能够被GC回收</code>(避免内存泄漏)</li>
  <li>
    <p>不再使用的内存对象、或着大型内存，<code class="highlighter-rouge">使用结束(虚引用)马上回收</code>(<code class="highlighter-rouge">finalize()方法进行清理</code>，通过 java.lang.ref.PhantomReference实现)</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  我们进行内存分析具体分析什么呢？
  1. 大型对象
  2. 不使用的未能被释放的对象(内存泄漏)
	
  而谷歌目前提供的内存分析工具只能从宏观上进行内存分析，无法针对某个对象进行分析
	
  这里我们这里需要使用强大的第三方内存分析工具MAT(Memory Analyzer Tool)针对具体内存进行分析
</code></pre>
    </div>
  </li>
</ul>

<h3 id="mat-1">4. MAT基础知识</h3>

<ul>
  <li>MAT简介
    <ul>
      <li>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</li>
      <li>当然MAT也有独立的不依赖Eclipse的版本，只不过这个版本在调试Android内存的时候，需要将DDMS生成的文件进行转换，才可以在独立版本的MAT上打开。不过Android SDK中已经提供了这个Tools，所以使用起来也是很方便的。</li>
    </ul>
  </li>
  <li>
    <p>MAT下载地址</p>

    <ul>
      <li>
        <p>独立版本下载地址： https://eclipse.org/mat/downloads.php
  这种方式有个麻烦的地方就是DDMS导出的文件，需要进行转换才可以在MAT中打开。</p>
      </li>
      <li>
        <p>Eclipse插件地址：http://download.eclipse.org/mat/1.5/update-site/</p>
      </li>
    </ul>
  </li>
  <li>MAT中重要概念介绍
  <code class="highlighter-rouge">要看懂MAT的列表信息，Shallow heap、Retained Heap、GC Root 这几个概念一定要弄懂。</code>
    <ul>
      <li>Shallow heap
  <code class="highlighter-rouge">Shallow size就是对象本身占用内存的大小，不包含其引用的对象。</code>
        <ol>
          <li>常规对象<code class="highlighter-rouge">（非数组）的Shallow size有其成员变量的数量和类型决定。</code></li>
        </ol>
      </li>
    </ul>

    <ol>
      <li>
        <p><code class="highlighter-rouge">数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定 </code></p>

        <div class="highlighter-rouge"><pre class="highlight"><code> 因为不像c++的对象本身可以存放大量内存，java的对象成员都是些引用。真正的内存都在堆上，看起来是一堆原生的byte[],char[], int[]，所以我们如果只看对象本身的内存，那么数量都很小。所以我们看到Histogram图是以Shallow size进行排序的，排在第一位第二位的是byte，char 。
</code></pre>
        </div>
      </li>
    </ol>

    <ul>
      <li>
        <p>Retained Heap</p>

        <p><code class="highlighter-rouge">Retained Heap的概念：如果一个对象被释放掉，那么该对象引用的所有对象（包括被递归释放的）占用的heap也会被释放。</code></p>

        <p>如果一个对象的某个成员new了一大块int数组，那这个int数组也可以计算到这个对象中。<code class="highlighter-rouge">与shallow heap比较，Retained heap可以更精确的反映一个对象实际占用的大小</code>（因为如果该对象释放，retained heap都可以被释放）。</p>

        <p>注意：A和B都引用到同一内存，A释放时，该内存不会被释放。所以这块内存不会被计算到A或者B的Retained Heap中。故<code class="highlighter-rouge">Retained Heap并不总是那么有效。 </code></p>

        <p>这一点并不重要，因为MAT引入了Dominator Tree－－对象引用树，计算Retained Heap就会非常方便，显示也非常方便。对应到MAT UI上，在dominator tree这个view中，显示了每个对象的shallow heap和retained heap。然后可以以该节点为树根，一步步的细化看看retained heap到底是用在什么地方了。</p>
      </li>
      <li>
        <p>GC Root</p>

        <p><code class="highlighter-rouge">GC发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收。</code></p>

        <p><img src="http://img.blog.csdn.net/20131025114957718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2VtbWVt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="这里写图片描述" /></p>

        <p><img src="http://img.blog.csdn.net/20151127104034762" alt="这里写图片描述" /></p>

        <p>名词GC Roots正是分析这一过程的起点，例如JVM自己确保了对象的可到达性(那么JVM就是GC Roots)，所以GC Roots就是这样在内存中保持对象可到达性的，一旦不可到达，即被回收。</p>

        <p>通常GC Roots是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以<code class="highlighter-rouge">GC Roots是分析对象为何还存活于内存中的利器。</code></p>
      </li>
    </ul>
  </li>
  <li>MAT界面功能介绍
    <ul>
      <li>打开经过转换的hprof文件：
  <img src="http://img.blog.csdn.net/20151127103729946" alt="这里写图片描述" />
  可不选</li>
      <li>Actions区域，几种分析方法：
        <ul>
          <li>
            <p>Histogram：列出内存中的对象，对象的个数以及大小
  <img src="http://img.blog.csdn.net/20151127103905066" alt="这里写图片描述" /></p>
          </li>
          <li>
            <p>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的） 
  <img src="http://img.blog.csdn.net/20151127103921964" alt="这里写图片描述" /></p>
          </li>
        </ul>

        <blockquote>
          <p>点开每个对象，<code class="highlighter-rouge">检查内部的超大对象</code></p>
        </blockquote>

        <ul>
          <li>Top Consumers ： 通过图形列出最大的object 
  <img src="http://img.blog.csdn.net/20151127103941622" alt="这里写图片描述" /></li>
        </ul>

        <blockquote>
          <p>一般Histogram和 Dominator Tree是最常用的。</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>MAT分析对象的引用
    <ul>
      <li>
        <p>Path to GC Root
  在Histogram或者Domiantor Tree的某一个条目上，右键可以查看其GC Root Path：
  <img src="http://img.blog.csdn.net/20151127104314761" alt="这里写图片描述" /></p>
      </li>
      <li>
        <p>点击Path To GC Roots –&gt; with all references</p>

        <p><img src="http://img.blog.csdn.net/20151127104222628" alt="这里写图片描述" /></p>

        <blockquote>
          <p>通过这个图<code class="highlighter-rouge">查看(内存泄漏)</code>该内存还被谁所引用，为何还不能释放</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>MAT基础介绍来自<a href="http://www.jianshu.com/p/d8e247b1e7b2#">Gracker</a></li>
</ul>

<h1 id="section-3">三、内存问题总览</h1>

<ul>
  <li>内存泄漏
    <ul>
      <li>
        <p>非静态内部类的静态实例容易造成内存泄漏
  非静态内部类的存活需要依赖外部类</p>
      </li>
      <li>
        <p>Activity使用静态成员(静态成员引用Drawable、Bitmap等大内存对象)</p>
      </li>
      <li>
        <p>使用handler时的内存问题
  因为Handler的非即时性，导致部分代码不能及时释放
  可以使用Badoo开发的第三方的 <a href="https://github.com/badoo/android-weak-handler">WeakHandler</a></p>
      </li>
      <li>
        <p>注册某个对象后未反注册
  注册广播接收器、注册观察者等等</p>
      </li>
      <li>
        <p>集合中对象没清理造成的内存泄露</p>
      </li>
      <li>
        <p>资源对象没关闭造成的内存泄露
  资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。</p>
      </li>
    </ul>
  </li>
  <li>一些不良代码成内存压力
    <ul>
      <li>循环以及递归</li>
      <li>数据随意申请大小</li>
      <li>如果没有用到不要定义全局变量</li>
    </ul>
  </li>
  <li>Bitmap使用不当
    <ul>
      <li>及时的销毁</li>
    </ul>

    <p>虽然，系统能够确认Bitmap分配的内存最终会被销毁，但是由于它占用的内存过多，所以很可能会超过Java堆的限制。因此，在用完Bitmap时，要<code class="highlighter-rouge">及时的recycle掉</code>。recycle并不能确定立即就会将Bitmap释放掉，但是会给虚拟机一个暗示：“该图片可以释放了”。</p>

    <ul>
      <li>
        <p>设置一定的采样率(二次采样)
  有时候，我们要显示的区域很小，没有必要将整个图片都加载出来，而只需要记载一个缩小过的图片，这时候可以设置一定的采样率，那么就可以大大减小占用的内存。</p>
      </li>
      <li>
        <p>巧妙的运用软引用（SoftRefrence）</p>

        <p>有些时候，我们使用Bitmap后没有保留对它的引用，因此就无法调用Recycle函数。这时候巧妙的运用软引用，可以使Bitmap在内存快不足时得到有效的释放
  目前但凡是个图片加载框架都会使用SoftRefrence</p>
      </li>
    </ul>
  </li>
  <li>
    <p>构造Adapter时，没有使用缓存的 convertView</p>
  </li>
  <li>频繁的方法中创建对象
  不要在经常调用的方法中创建对象，尤其是忌讳在循环中创建对象。可以适当的使用 hashtable ， vector 创建一组对象容器，然后从容器中去取那些对象，而不用每次 new 之后又丢弃。</li>
</ul>

<h1 id="mat-2">四、MAT内存分析</h1>

<ul>
  <li>
    <p>使用Dominator Tree -&gt; Path To GC Roots –&gt; with all references 
  上面MAT基础里面已经讲</p>
  </li>
  <li>
    <p>根据某种类型的对象个数来分析内存泄漏。
  Actions -&gt; Histogram
  <img src="http://img.blog.csdn.net/20131025120850406" alt="这里写图片描述" /></p>

    <p>上图展示了内存中各种类型的对象个数和Shallow heap，我们看到byte[]占用Shallow heap最多，那是因为Honeycomb之后Bitmap Pixel Data的内存分配在Dalvik heap中。右键选中byte[]数组，选择List Objects -&gt; with incomingreferences，可以看到byte[]具体的对象列表：</p>

    <p><img src="http://img.blog.csdn.net/20131025123513640" alt="这里写图片描述" /></p>

    <p><img src="http://img.blog.csdn.net/20131025123529984" alt="这里写图片描述" /></p>

    <p>我们发现第二个byte[]的Retained heap较大，内存泄漏的可能性较大，因此右键选中这行，Path To GC Roots -&gt; exclude weak references，同样可以看到上文所提到的情况，我们的Bitmap对象被leak所引用到，这里存在着内存泄漏。</p>

    <p><img src="http://img.blog.csdn.net/20131025121635500" alt="这里写图片描述" /></p>
  </li>
</ul>

<blockquote>
  <ol>
    <li>讲的是对象及其应用的内存大小</li>
    <li>讲的是大型对象被谁所引用</li>
  </ol>
</blockquote>

<p>内存分析工具还有一个比较流行的内存泄漏检测库：<a href="http://www.liaohuqiu.net/cn/posts/leak-canary/">LeakCannary</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Object-Oriented</title>
	  <link>//object-oriented</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-04-23T00:00:00+08:00</pubDate>
	  <guid>//object-oriented</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>本篇是根据高焕堂老师的课程归纳记录的，所讲内容包括：Oriented、Class、extends(继承&amp;扩展)、implements、组合、(前三个均有的)Hook方法、IoC(主动调用、被动调用)</p>
</blockquote>

<h2 id="oriented-">1. Oriented 面向</h2>

<ul>
  <li>Oriented 意味着一种信仰（万物皆对象）</li>
  <li>Object-oriented 相信任何软件都是由对象所构成的，而且Nothing else.</li>
  <li>根据上述信仰，电脑语言的设计就简化了，写程序只要定义类别（Class）就行了</li>
</ul>

<h2 id="orientedbaseddrivencentered">2. Oriented、Based、Driven、Centered之间的区别?</h2>
<ul>
  <li>
    <p>Based 的涵义 
例如：Requirement-based基于需求
Requirement-base software development</p>
  </li>
  <li>
    <p>Driven 的涵义
例如：Model-driven（模型引导） 、Use Case-driven（用户使用引导）
其实driven 是“引导”，而不是大家常常说说的“驱动”
就像北极星引导我们，指出方向而已，也像汽车司机(Driver)只是引导汽车方向，并没有去驱动汽车；而引擎才是驱动汽车。</p>
  </li>
  <li>
    <p>Centered 的涵义
例如：Architecture-centered(建筑中心) <br />
一切软件开发的活动都围绕着架构，就像圣诞节的糖果和礼物都挂在圣诞树上一样(圣诞树centric)</p>
  </li>
  <li>
    <p>Service-Oriented Architecture(SOA)
SOA 是什么含义呢？
相信软件都是以服务构成的，Nothing else!</p>
  </li>
  <li>
    <p>对象(Object)
对个人而言，所认识的东西，皆对象（不认识的就不是对象）
认识的东西，就能说出其特点，并与别的对象比较一番。（其特点包括：对象之特征或属性（Attribute)、对象之行为(Behavior)）</p>
  </li>
  <li>
    <p>软件之对象(Software Object)是由数据(Data)和函数(Function)所组成。</p>
  </li>
</ul>

<h2 id="section">3. 类的用途</h2>

<ul>
  <li>
    <p>类(Class)是群体(或集合)，而对象是类中的一份子。人们常用［是一个］（is A）来表达对象与类之间的关系</p>
  </li>
  <li>例如：
  月亮是一个星球
  毕加索是一个艺术家
  毕加索是一个画家
  张大千是一个画家</li>
  <li>
    <p>所以［月球］是对象，属于［星球］类的一个实例（Instance）。毕加索是一个对象，艺术家是一个类，同样的画家也是类，其中画家也是艺术家群体中的小群体（部分集合）。毕加索和张大千同属于［画家］类，所以具有共同点：精于美术绘画</p>
  </li>
  <li>类所对应的一群具有同样特征的对象集合。</li>
</ul>

<h2 id="section-1">4.  &lt;基类/子类&gt;结构用途 （一）</h2>
<ul>
  <li>
    <p>表达继承（继承是扩充的一种）inheritence(继承、遗产)
extends 不仅仅是继承，也是扩充</p>
  </li>
  <li>
    <p>对众多对象加以分门别类，就可以形成一个类继承体系。</p>
  </li>
  <li>
    <p>overrite 其实并没有复写，只是名字参数相同，那么调用的时候，会调用子类的这个方法，不过方法内部可以使用super.xxx方法调用父类的此方法。</p>
  </li>
</ul>

<h2 id="section-2">5.  &lt;基类/子类&gt;结构用途（二）表达组合</h2>
<ul>
  <li>组合与被组合结构上有类似继承的结构（方法相同）</li>
  <li>组合之间尽量使用接口（针对接口编程，也是一种协议）</li>
</ul>

<h2 id="hook">6.  &lt;基类/子类&gt; 结构的 接口(卡榫函数 Hook)</h2>
<ul>
  <li>
    <p>(卡榫  字义就是 机械上的起定位和固定作用的卡子 ) Interface</p>
  </li>
  <li>
    <p>所谓Hook，就是接口，如果两个东西不同时间出现，
则一方会预留虚空，给予另一边于未来时刻能以实体来
填补该空间，两者虚实相依，就密合起来了。设计优良的卡榫，
可以让实体易于新陈代谢、抽换自如（Plug and Play，俗称PnP:即插即用）</p>
  </li>
  <li>
    <p>Template Method 模板方法模式（GoF）(模板方法)
<img src="http://img.blog.csdn.net/20160423202924230" alt="这里写图片描述" /></p>
  </li>
  <li>
    <p>父类中调用被子类overridable的方法，真是调用的其实是子类的同名同参方法，其实父类的方法依旧是存在的，可以在子类方法中调用super.xxx()实现调用父类此方法。</p>
  </li>
  <li>
    <p>变与不变的分离(Separate code that changes from the code that doesn’t)是设计卡榫函数及应用框架之基本原则和手艺。</p>
  </li>
  <li>
    <p>分离出变(Variant)与不变(Invariant)部分之后，就可以将不变部分写在父类别（Super-class)里，而变的部分就写在子类别(Subclass)里。</p>
  </li>
  <li>
    <p>继承与组合都需要Hook Function来对接</p>
  </li>
</ul>

<h2 id="iocdefault">7. IoC机制与Default函数</h2>

<ul>
  <li>
    <p>卡榫函数实现IoC机制</p>
  </li>
  <li>
    <p>控制反转(IoC:Inversion of Control)
IoC机制源于OO语言的继承体系，基类的函数可以主动调用子类的函数，这就是典型的IoC机制。</p>
  </li>
  <li>
    <p>注：子类调用基类：正向
  基类调用子类：控制反转</p>
  </li>
  <li>
    <p>基类与子类之间，控制权是在基类手上，透过Hook函数来调用子类</p>
  </li>
  <li>
    <p>通常基类是写在先，而子类则写在后，这种前辈拥有主导权，进而控制后辈的情形，就统称为控制反转。</p>
  </li>
  <li>
    <p>默认Default行为
基类的重要功能：提供默认(预设)行为
基类可事先定义许多［默认］(Default)函数，这些默认函数可让子类来继承(或调用)之。</p>
  </li>
</ul>

<h2 id="vs-api">8. 主动型vs被动型 API</h2>
<ul>
  <li>
    <p>模块跟模块之间 API
系统跟人之间   UI : User Interface</p>
  </li>
  <li>
    <p>卡榫函数实现API</p>
  </li>
  <li>
    <p>主动型API：反向/IOC调用
被动型API：正向
(其实是站在父类的角度讲的、基类的视角)</p>
  </li>
  <li>
    <p>API的分类
定义(Define)
实作(Implement)
呼叫(Invoke or Call)</p>
  </li>
  <li>
    <p>根据这三个角度，可捋API区分为[主动型]与[被动型]两种。</p>
  </li>
  <li>
    <p>被动型缺乏弹性</p>
  </li>
  <li>
    <p>API &gt;= 控制力
接口(interface)是双方接触的地方，也是双方势力或
地盘的界限。谁拥有接口的指定权，谁就掌握控制点，掌握了主动权。</p>
  </li>
  <li>
    <p>Activity onCreate 就是一种主动型的API</p>
  </li>
</ul>

<h2 id="section-3">9. 结语&amp;复习：接口与类(别)</h2>

<ul>
  <li>
    <p>在OOP里，将接口定义为一种特殊的类别(Class)</p>
  </li>
  <li>
    <p>在C++里，类别包括3种：
1.一般(具象)类别
所有函数都是具象(内有指令)
2.抽象(abstract)类别
有一个或多个函数是抽象的(内无指令)
3.纯粹抽象(pure abstract)类别
所有函数都是抽象的(java 中 的 接口)</p>
  </li>
  <li>
    <p>在UML里，以圆圈来表示接口</p>
  </li>
</ul>

<hr />

<h3 id="section-4">一、面向对象编程思想：封装、继承、多肽、六大基本原则、设计模式等等。。。</h3>

<h3 id="section-5">二、面向对象的六大基本原则包括哪些？</h3>
<ol>
  <li>单一职责原则</li>
  <li>开闭原则
  –对扩展开放，对修改关闭</li>
  <li>
    <p>里氏替换原则
  –使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性</p>
  </li>
  <li>依赖倒置原则
A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。
B.抽象不应该依赖于具体，具体应该依赖于抽象。</li>
  <li>
    <p>接口隔离原则
  –客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
  </li>
  <li>迪米特法则
  –最少知识原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象有尽可能少的了解,不和陌生人说话</li>
</ol>

<h3 id="section-6">三、单一职责原则</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>SRP：Single Responsibility Principle

--ImageLoader案例
 图片显示、图片缓存、图片下载功能分开 &gt;	(思维方式)利他之心，我们写代码是给别人看的，是给别人用的
</code></pre>
</div>

<h3 id="section-7">四、开闭原则</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>类、某块、函数等等.....(可扩展、不可修改)
对扩展开放，对修改关闭
</code></pre>
</div>

	  ]]></description>
	</item>

	<item>
	  <title>Android动画(5.0以下)</title>
	  <link>//animation</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-04-20T00:00:00+08:00</pubDate>
	  <guid>//animation</guid>
	  <description><![CDATA[
	     <p>使用Android两年多了，工作中的动画也动能应付，自认为Android中的动画自己也能用个八九不离十，结果我在学习<a href="http://www.jianshu.com/p/03fdcfd3ae9c">Periscope点赞效果</a>的时候发现动画的这些高级功能我从没用过、也没见过，静下来仔细想了下，我也并不明白Android动画的实现原理，以及生么时候用什么，从视频以及ApiDemo中看到的LayoutAnimator以及颜色渐变、类似弹簧的反复回弹也都没思路。于是我就研究了下Android的这些动画并记录了下来。</p>

<hr />

<div class="highlighter-rouge"><pre class="highlight"><code>3.0以前，android支持两种动画模式,tween animation,frame animation，在3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation
</code></pre>
</div>

<h1 id="view-animationtween-animation">1. View Animation（Tween Animation）</h1>

<blockquote>
  <p>View Animation(Tween Animation):补间动画，给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。(xml方式是在anim文件夹中)</p>
</blockquote>

<blockquote>
  <ul>
    <li>View Animation只能用于View对象，而且职能支持一部分功能：位移(translate)、旋转(rotate)、缩放(scale)、透明度渐变(alpha)</li>
    <li>还有一个局限性：对于View Animation，它只是改变了View对象绘制的位置，而没有改变View对象本身（例如：做一个位移动画，那么可点击的位置仅仅还是View开始所在的位置，跟移动中的这个动画并无关系）</li>
    <li><strong>实现原理</strong>：是父布局不断的画出一个外表一样的图像，不断的通过invalidate 去进行重绘，动画的算法其实都是在Transformation的Matrix矩阵中。</li>
  </ul>
</blockquote>

<h1 id="drawable-animationframe-animation">2. Drawable Animation（Frame Animation）</h1>
<p>Drawable Animation（Frame Animation）：帧动画，就像GIF图片，通过一系列Drawable依次显示来模拟动画的效果。(xml方式是在drawable中)</p>

<p>Android中播放GIF图片的时候，可使用这种方式(先分解成单个图片)。</p>

<h1 id="property-animation">3. Property Animation</h1>
<p>Android 3.0引入，顾名思义，它是实际更改view的属性，而不像Tween Animation 仅仅是父布局绘制一个替身，所以Property Animation的功能会强大很多。(在包android.animation下)</p>

<h3 id="section">相同：</h3>
<p>Property Animation 兼容了 Tween Animation的所有功能：设置动画时间、支持(位移、旋转、缩放、透明度渐变)、类似的监听(开始、结束、取消、重复)、插补器
### 加强功能：
后浪推前浪，后出来的Property Animation带来了更强悍的功能：
#### 1. Evaluators(计算器)：告诉Property Animation系统如何去计算属性值</p>

<blockquote>
  <ul>
    <li>IntEvaluator:用于计算Int类型属性值的计算器。</li>
    <li>FloatEvaluator:用于计算Float类型属性值的计算器。</li>
    <li>ArgbEvaluator:用于计算以16进制形式表示的颜色值的计算器。</li>
    <li>TypeEvaluator:一个计算器接口，它允许你创建你自己的计算器。如果你正在计算一个对象属性并不是int,float或者颜色值类型的，那么你必须实现TypeEvaluator接口去指定如何去计算对象的属性值。</li>
  </ul>
</blockquote>

<h4 id="valueanimatoranimatorupdatelistener-">2. 新加了ValueAnimator.AnimatorUpdateListener 监听</h4>
<p>　　onAnimationUpdate() - 在动画的每一帧上调用. 在这个方法中，你可以使用ValueAnimator的getAnimatedValue()方法来获取(Evaluators)计算出来的值。
AnimationSet提供了一个把多个动画组合成一个组合的机制，并可设置组中动画的时序关系，如同时播放，顺序播放等。</p>

<h4 id="view">3. 新增属性动画的同时，也新增了View的属性的设置获取方法</h4>
<p>　Example：getLeft、getX、getTranslationX等等</p>

<h4 id="animationset">4. 通过AnimationSet应用多个动画</h4>
<p>　　以下例子同时应用5个动画：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>播放anim1；
同时播放anim2,anim3,anim4；
播放anim5。 　　
</code></pre>
</div>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="n">AnimatorSet</span> <span class="n">bouncer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AnimatorSet</span><span class="o">();</span>
    <span class="n">bouncer</span><span class="o">.</span><span class="na">play</span><span class="o">(</span><span class="n">anim1</span><span class="o">).</span><span class="na">before</span><span class="o">(</span><span class="n">anim2</span><span class="o">);</span>
    <span class="n">bouncer</span><span class="o">.</span><span class="na">play</span><span class="o">(</span><span class="n">anim2</span><span class="o">).</span><span class="na">with</span><span class="o">(</span><span class="n">anim3</span><span class="o">);</span>
    <span class="n">bouncer</span><span class="o">.</span><span class="na">play</span><span class="o">(</span><span class="n">anim2</span><span class="o">).</span><span class="na">with</span><span class="o">(</span><span class="n">anim4</span><span class="o">)</span>
    <span class="n">bouncer</span><span class="o">.</span><span class="na">play</span><span class="o">(</span><span class="n">anim5</span><span class="o">).</span><span class="na">after</span><span class="o">(</span><span class="n">amin2</span><span class="o">);</span>
    <span class="n">animatorSet</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre></figure>

<h4 id="objectanimatorvalueanimator">5. ObjectAnimator与ValueAnimator之间的关系：</h4>
<p>　　其实ObjectAnimator继承与ValueAnimator，ObjectAnimator是为了提供简便的方法，可以直接修改alpha、backgroundColor、translationX、x、y、width等，甚至是一个普通对象的属性，一言以蔽之如果直接通过属性名改属性就用ObjectAnimator</p>

<blockquote>
  <p>例子：<a href="http://www.jianshu.com/p/03fdcfd3ae9c">Periscope点赞效果实现</a>
<img src="http://img.blog.csdn.net/20160419161534918" alt="这里写图片描述" /></p>
</blockquote>

<p>　　我又换了种方式实现了下，运用我们的属性动画，直接在ViewGroup上画出来：
　　<img src="http://img.blog.csdn.net/20160420165151408" alt="这里写图片描述" /></p>

<p>　　<a href="http://download.csdn.net/detail/yuanyang5917/9497167">代码传送门</a></p>

<h4 id="section-1">6. 同一对象的多个属性同时变化可优化</h4>
<p>　　如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图，该类在3.1中引入。</p>

<p>　　以下两段代码实现同样的效果：　</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">PropertyValuesHolder</span> <span class="n">pvhX</span> <span class="o">=</span> <span class="n">PropertyValuesHolder</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="s">"x"</span><span class="o">,</span> <span class="mi">50</span><span class="n">f</span><span class="o">);</span>
<span class="n">PropertyValuesHolder</span> <span class="n">pvhY</span> <span class="o">=</span> <span class="n">PropertyValuesHolder</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="s">"y"</span><span class="o">,</span> <span class="mi">100</span><span class="n">f</span><span class="o">);</span>
<span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofPropertyValuesHolder</span><span class="o">(</span><span class="n">myView</span><span class="o">,</span> <span class="n">pvhX</span><span class="o">,</span> <span class="n">pvyY</span><span class="o">).</span><span class="na">start</span><span class="o">();</span></code></pre></figure>

<h4 id="evaluatorviewhandlerpostuiview">7. <strong>原理</strong>：异步根据插补器与Evaluator计算出当前View的属性，再通过handler.post到UI线程，通过反射给View设置当前属性。</h4>
<p><a href="http://zhouyunan2010.iteye.com/blog/1972789">老版本的Property Animation原理讲解</a></p>

<blockquote>
  <h3 id="tween-animation--property-animation-">Tween Animation 与 Property Animation 使用选择：</h3>
  <p>因为Property Animation最终跟新UI其实也需要重新绘图，所以，属性动画肯定比Tween Animation要更好性能得多，理论上流畅度也稍稍差点。
<strong>所以建议能用Tween Animation的地方，还是使用Tween 动画。</strong></p>
</blockquote>

<hr />

<h1 id="apidemo">根据ApiDemo罗列了以下几个实用场景（此处会有不少新的用法）：</h1>

<h2 id="section-2">1. 颜色渐变</h2>

<p><img src="http://img.blog.csdn.net/20160420095341051" alt="这里写图片描述" /></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">RED</span> <span class="o">=</span> <span class="mh">0xff</span><span class="n">FF8080</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">BLUE</span> <span class="o">=</span> <span class="mh">0xff8080</span><span class="n">FF</span><span class="o">;</span>

<span class="n">ValueAnimator</span> <span class="n">colorAnim</span> <span class="o">=</span> <span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofInt</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">"backgroundColor"</span><span class="o">,</span> <span class="n">RED</span><span class="o">,</span> <span class="n">BLUE</span><span class="o">);</span>
    <span class="n">colorAnim</span><span class="o">.</span><span class="na">setDuration</span><span class="o">(</span><span class="mi">3000</span><span class="o">);</span>
    <span class="n">colorAnim</span><span class="o">.</span><span class="na">setEvaluator</span><span class="o">(</span><span class="k">new</span> <span class="n">ArgbEvaluator</span><span class="o">());</span>
    <span class="n">colorAnim</span><span class="o">.</span><span class="na">setRepeatCount</span><span class="o">(</span><span class="n">ValueAnimator</span><span class="o">.</span><span class="na">INFINITE</span><span class="o">);</span>
    <span class="n">colorAnim</span><span class="o">.</span><span class="na">setRepeatMode</span><span class="o">(</span><span class="n">ValueAnimator</span><span class="o">.</span><span class="na">REVERSE</span><span class="o">);</span>
    <span class="n">colorAnim</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre></figure>

<h2 id="layouttransition">2. 布局显示、不显示、隐藏(LayoutTransition)</h2>

<p><img src="http://img.blog.csdn.net/20160420174213674" alt="这里写图片描述" />
ViewGroup中的子元素可以通过setVisibility使其Visible、Invisible或Gone，当有子元素可见性改变时，可以向其应用动画，通过LayoutTransition类应用此类动画：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">transition</span><span class="o">.</span><span class="na">setAnimator</span><span class="o">(</span><span class="n">LayoutTransition</span><span class="o">.</span><span class="na">DISAPPEARING</span><span class="o">,</span> <span class="n">customDisappearingAnim</span><span class="o">);</span></code></pre></figure>

<p>　　通过setAnimator应用动画，第一个参数表示应用的情境，可以以下4种类型：</p>

<ul>
  <li>APPEARING　　　　　　　　当一个元素变为Visible时对其应用的动画</li>
  <li>CHANGE_APPEARING　　　当一个元素变为Visible时，因系统要重新布局有一些元素需要移动，这些要移动的元素应用的动画</li>
  <li>DISAPPEARING　　　　　　当一个元素变为InVisible时对其应用的动画</li>
  <li>CHANGE_DISAPPEARING　当一个元素变为Gone时，因系统要重新布局有一些元素需要移动，这些要移动的元素应用的动画 disappearing from the 
container.</li>
</ul>

<blockquote>
  <p>步骤：
1. 给view设置LayoutTransition
　 LayoutTransition mTransitioner = new LayoutTransition();
　view.setLayoutTransition(mTransitioner);
2. 设置对应时间
　 Transitioner.setStagger(LayoutTransition.CHANGE_APPEARING, 500);
3. 设置动画
　ObjectAnimator changeIn = ObjectAnimator.ofPropertyValuesHolder(
                        this, pvhLeft, pvhRight, pvhScaleX, pvhScaleY).
                setDuration(mTransitioner.getDuration(LayoutTransition.CHANGE_APPEARING));
        mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING, changeIn);
4.  搞定</p>
</blockquote>

<h2 id="keyframes">3. Keyframes</h2>
<p>　 keyFrame是一个 时间/值 对，通过它可以定义一个在特定时间的特定状态，而且在两个keyFrame之间可以定义不同的Interpolator，就相当多个动画的拼接，第一个动画的结束点是第二个动画的开始点。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="n">Keyframe</span> <span class="n">kf0</span> <span class="o">=</span> <span class="n">Keyframe</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="mi">0</span><span class="n">f</span><span class="o">);</span>
    <span class="n">Keyframe</span> <span class="n">kf1</span> <span class="o">=</span> <span class="n">Keyframe</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(.</span><span class="mi">9999</span><span class="n">f</span><span class="o">,</span> <span class="mi">360</span><span class="n">f</span><span class="o">);</span>
    <span class="n">Keyframe</span> <span class="n">kf2</span> <span class="o">=</span> <span class="n">Keyframe</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="mi">1</span><span class="n">f</span><span class="o">,</span> <span class="mi">0</span><span class="n">f</span><span class="o">);</span>
    <span class="n">PropertyValuesHolder</span> <span class="n">pvhRotation</span> <span class="o">=</span>
    <span class="n">PropertyValuesHolder</span><span class="o">.</span><span class="na">ofKeyframe</span><span class="o">(</span><span class="s">"rotation"</span><span class="o">,</span> <span class="n">kf0</span><span class="o">,</span> <span class="n">kf1</span><span class="o">,</span> <span class="n">kf2</span><span class="o">);</span>
    <span class="kd">final</span> <span class="n">ObjectAnimator</span> <span class="n">changeOut</span> <span class="o">=</span> <span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofPropertyValuesHolder</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">pvhLeft</span><span class="o">,</span> <span class="n">pvhRight</span><span class="o">,</span> <span class="n">pvhRotation</span><span class="o">).</span><span class="na">setDuration</span><span class="o">(</span><span class="n">mTransitioner</span><span class="o">.</span><span class="na">getDuration</span><span class="o">(</span><span class="n">LayoutTransition</span><span class="o">.</span><span class="na">CHANGE_DISAPPEARING</span><span class="o">));</span></code></pre></figure>

<h2 id="section-3">4. 弹跳</h2>

<p><img src="http://img.blog.csdn.net/20160420220757849" alt="这里写图片描述" />
弹跳插补器：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">bounceAnim</span><span class="o">.</span><span class="na">setInterpolator</span><span class="o">(</span><span class="k">new</span> <span class="n">BounceInterpolator</span><span class="o">());</span></code></pre></figure>

<p><img src="http://img.blog.csdn.net/20160420220818740" alt="这里写图片描述" />
设置特定一个时间点，显示在那帧位置上</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">bounceAnim</span><span class="o">.</span><span class="na">setCurrentPlayTime</span><span class="o">(</span><span class="n">seekTime</span><span class="o">);</span></code></pre></figure>

<h2 id="section-4">5. 反转切换布局</h2>
<p><img src="http://img.blog.csdn.net/20160420221214985" alt="这里写图片描述" /></p>

<p>其实就是一个旋转动画的拼接，一组对立的插补器(加速AccelerateInterpolator、减速DecelerateInterpolator)</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">ObjectAnimator</span> <span class="n">visToInvis</span> <span class="o">=</span> <span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="n">visibleList</span><span class="o">,</span> <span class="s">"rotationY"</span><span class="o">,</span> <span class="mi">0</span><span class="n">f</span><span class="o">,</span> <span class="mi">90</span><span class="n">f</span><span class="o">);</span>
        <span class="n">visToInvis</span><span class="o">.</span><span class="na">setDuration</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="n">visToInvis</span><span class="o">.</span><span class="na">setInterpolator</span><span class="o">(</span><span class="n">accelerator</span><span class="o">);</span>
        <span class="kd">final</span> <span class="n">ObjectAnimator</span> <span class="n">invisToVis</span> <span class="o">=</span> <span class="n">ObjectAnimator</span><span class="o">.</span><span class="na">ofFloat</span><span class="o">(</span><span class="n">invisibleList</span><span class="o">,</span> <span class="s">"rotationY"</span><span class="o">,</span>
                <span class="o">-</span><span class="mi">90</span><span class="n">f</span><span class="o">,</span> <span class="mi">0</span><span class="n">f</span><span class="o">);</span>
        <span class="n">invisToVis</span><span class="o">.</span><span class="na">setDuration</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="n">invisToVis</span><span class="o">.</span><span class="na">setInterpolator</span><span class="o">(</span><span class="n">decelerator</span><span class="o">);</span>
        <span class="n">visToInvis</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">AnimatorListenerAdapter</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="n">onAnimationEnd</span><span class="o">(</span><span class="n">Animator</span> <span class="n">anim</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">visibleList</span><span class="o">.</span><span class="na">setVisibility</span><span class="o">(</span><span class="n">View</span><span class="o">.</span><span class="na">GONE</span><span class="o">);</span>
                <span class="n">invisToVis</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
                <span class="n">invisibleList</span><span class="o">.</span><span class="na">setVisibility</span><span class="o">(</span><span class="n">View</span><span class="o">.</span><span class="na">VISIBLE</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">visToInvis</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre></figure>

	  ]]></description>
	</item>

	<item>
	  <title>注解初始化控件(ButterKnife方式)<下></title>
	  <link>//butterknifedemo02</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-04-13T00:00:00+08:00</pubDate>
	  <guid>//butterknifedemo02</guid>
	  <description><![CDATA[
	     <p>一个星期没更新博客了，虽然目前博客很乱！最近比较忙，视力有些下降，不过ButterKnife的事件实现终算完成了！</p>

<blockquote>
  <h3 id="butterknifedemohttpdownloadcsdnnetdetailyuanyang59179489865"><a href="http://download.csdn.net/detail/yuanyang5917/9489865">ButterKnifeDemo实现(注解完善，方便阅读)</a></h3>
</blockquote>

<h2 id="section">目标</h2>
<p>之所以butterknife可以实现点击view的时候调用注解过的方法，其实是在点击的回调方法中调用目标类的相应注释过的方法：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">        <span class="n">view</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">DebouncingOnClickListener</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="n">doClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">target</span><span class="o">.</span><span class="na">click</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span></code></pre></figure>

<p>拿我的demo为例，我们最终是要生成一个如下的类：</p>

<p>这里写代码片</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">turbo</span><span class="o">.</span><span class="na">demo</span><span class="o">.</span><span class="na">apt</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.turbo.apt.library.internal.DebouncingOnClickListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.turbo.apt.library.internal.Finder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.turbo.apt.library.internal.ViewBinder</span><span class="o">;</span>

<span class="cm">/**
 * Created by LuckyTurbo on 16/4/11.
 *
 * 待生成的类
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity_ViewBinder</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">MainActivity</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">ViewBinder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">bind</span><span class="o">(</span><span class="n">Finder</span> <span class="n">finder</span><span class="o">,</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">target</span><span class="o">,</span> <span class="n">Object</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">View</span> <span class="n">view</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">,</span><span class="s">"textView 我 啊"</span><span class="o">);</span>
        <span class="n">target</span><span class="o">.</span><span class="na">textView</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">,</span><span class="s">"textView 我 啊"</span><span class="o">);</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">rightView</span><span class="o">,</span><span class="s">"rightView 我 啊"</span><span class="o">);</span>
        <span class="n">target</span><span class="o">.</span><span class="na">rightView</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">rightView</span><span class="o">,</span><span class="s">"rightView 我 啊"</span><span class="o">);</span>
        <span class="n">view</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">DebouncingOnClickListener</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="n">doClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">target</span><span class="o">.</span><span class="na">click</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span>

    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>那么下面要做的就是收集各种注解数据，然后再根据这些数据生成最终的类。</p>

<h2 id="section-1">收集数据</h2>
<p>绝大部分方法的数据都是从注解中获取的，那么我们如何设计注解呢？
### 注解设计分析
需求：
1.id
2.设置方法 (example:setOnLongClickListener)
3.接口类型 (android.view.View.OnLongClickListener)
4.接口中的方法：
1.方法名 (onLongClick)
2.参数类型 (android.view.View)
3.方法返回值 （boolean）</p>

<p>这么多东西如果在每个注解里面都加上，想想都恶心，但是注解并没有继承这一说，但是我们可以在注解的基础上再进行注解，上层注解里面可以设定默认值，每次给上层注解填值就可以了
——其实我们想要的就是规范，就是模版，其实就是针对规范编程</p>

<p>下面看下主要的几个注解：</p>

<ul>
  <li>@OnClick</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">CLASS</span><span class="o">)</span>
<span class="nd">@ListenerClass</span><span class="o">(</span>
        <span class="n">targetType</span> <span class="o">=</span> <span class="s">"android.view.View"</span><span class="o">,</span>
        <span class="n">setter</span> <span class="o">=</span> <span class="s">"setOnClickListener"</span><span class="o">,</span>
        <span class="n">type</span> <span class="o">=</span> <span class="s">"com.turbo.apt.library.internal.DebouncingOnClickListener"</span><span class="o">,</span><span class="c1">// 这个是butterKnife中的防卡点击</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nd">@ListenerMethod</span><span class="o">(</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s">"doClick"</span><span class="o">,</span>
                <span class="n">parameters</span> <span class="o">=</span> <span class="s">"android.view.View"</span><span class="o">,</span>
                <span class="n">returnType</span> <span class="o">=</span> <span class="s">"void"</span>
        <span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">OnClick</span> <span class="o">{</span>
    <span class="c1">// ids annotation注解 奇怪没导入成功</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">value</span><span class="o">()</span> <span class="k">default</span> <span class="o">{</span><span class="n">View</span><span class="o">.</span><span class="na">NO_ID</span><span class="o">};</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>@ListenerClass</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">ANNOTATION_TYPE</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span><span class="c1">// 靠，获取注解的注解好像必需要使用runtime，不然取不到</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">ListenerClass</span> <span class="o">{</span>
    <span class="c1">//    @ListenerClass(</span>
    <span class="c1">//            targetType = "android.view.View",</span>
    <span class="c1">//            setter = "setOnClickListener",</span>
    <span class="c1">//            type = "butterknife.internal.DebouncingOnClickListener",</span>
    <span class="c1">//            method = @ListenerMethod(</span>
    <span class="c1">//                    name = "doClick",</span>
    <span class="c1">//                    parameters = "android.view.View"</span>
    <span class="c1">//            )</span>
    <span class="c1">//    )</span>

    <span class="c1">// 某view</span>
    <span class="n">String</span> <span class="n">targetType</span><span class="o">();</span>
    <span class="c1">// 设置方法的名称</span>
    <span class="n">String</span> <span class="n">setter</span><span class="o">();</span>
    <span class="c1">// 接口全称</span>
    <span class="n">String</span> <span class="n">type</span><span class="o">();</span>
    <span class="cm">/** Enum which declares the listener callback methods. Mutually exclusive to {@link #method()}. */</span>
    <span class="c1">// 跟method互斥</span>
    <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Enum</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">callbacks</span><span class="o">()</span> <span class="k">default</span> <span class="n">NONE</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
    <span class="cm">/**
     * Method data for single-method listener callbacks. Mutually exclusive with {@link #callbacks()}
     * and an error to specify more than one value.
     */</span>
    <span class="n">ListenerMethod</span> <span class="n">method</span><span class="o">();</span>

    <span class="c1">// callback的默认值</span>
    <span class="kd">enum</span> <span class="n">NONE</span> <span class="o">{}</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>@ListenerMethod</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">ListenerMethod</span> <span class="o">{</span>

    <span class="c1">// listener 方法 的 名字</span>
    <span class="n">String</span> <span class="n">name</span><span class="o">();</span>

    <span class="c1">// 方法参数</span>
    <span class="n">String</span><span class="o">[]</span> <span class="n">parameters</span><span class="o">()</span> <span class="k">default</span> <span class="o">{};</span>

    <span class="c1">// 方法返回类型</span>
    <span class="n">String</span> <span class="n">returnType</span><span class="o">()</span> <span class="k">default</span> <span class="s">"void"</span><span class="o">;</span>

    <span class="cm">/** If {@link #returnType()} is not {@code void} this value is returned when no binding exists. */</span>
    <span class="c1">// 如果returnType 不是void，就返回这个值</span>
    <span class="n">String</span> <span class="n">defaultReturn</span><span class="o">()</span> <span class="k">default</span> <span class="s">"null"</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="section-2">注解收集数据结构</h3>
<p><img src="http://img.blog.csdn.net/20160413140458623" alt="这里写图片描述" /></p>

<h3 id="section-3">注解收集数据逻辑</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TypeElement</span><span class="o">,</span> <span class="n">VBinderBuilder</span><span class="o">&gt;</span> <span class="n">findAndParseTargets</span><span class="o">(</span><span class="n">RoundEnvironment</span> <span class="n">roundEnv</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NoSuchMethodException</span><span class="o">,</span> <span class="n">InvocationTargetException</span><span class="o">,</span> <span class="n">IllegalAccessException</span> <span class="o">{</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">TypeElement</span><span class="o">,</span> <span class="n">VBinderBuilder</span><span class="o">&gt;</span> <span class="n">vBinderBuilderMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedHashMap</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 解析所有的@Bind 元素</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">element</span> <span class="o">:</span> <span class="n">roundEnv</span><span class="o">.</span><span class="na">getElementsAnnotatedWith</span><span class="o">(</span><span class="n">Bind</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">TypeElement</span> <span class="n">typeElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">TypeElement</span><span class="o">)</span> <span class="n">element</span><span class="o">.</span><span class="na">getEnclosingElement</span><span class="o">();</span>
            <span class="n">VBinderBuilder</span> <span class="n">builderClass</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">vBinderBuilderMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">typeElement</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">builderClass</span> <span class="o">=</span> <span class="n">vBinderBuilderMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">typeElement</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">targetType</span> <span class="o">=</span> <span class="n">typeElement</span><span class="o">.</span><span class="na">getQualifiedName</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
                <span class="n">String</span> <span class="n">classPackage</span> <span class="o">=</span> <span class="n">getPackageName</span><span class="o">(</span><span class="n">typeElement</span><span class="o">);</span>
                <span class="c1">// packageName$className_ViewBinder</span>
                <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">getClassName</span><span class="o">(</span><span class="n">typeElement</span><span class="o">,</span> <span class="n">classPackage</span><span class="o">)</span> <span class="o">+</span> <span class="n">APTConfig</span><span class="o">.</span><span class="na">SUFFIX</span><span class="o">;</span>

                <span class="n">builderClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VBinderBuilder</span><span class="o">(</span><span class="n">classPackage</span><span class="o">,</span> <span class="n">className</span><span class="o">,</span> <span class="n">targetType</span><span class="o">);</span>
                <span class="n">vBinderBuilderMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">typeElement</span><span class="o">,</span> <span class="n">builderClass</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">Bind</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">value</span><span class="o">();</span>
            <span class="n">String</span> <span class="n">elementName</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
            <span class="n">TypeName</span> <span class="n">typeName</span> <span class="o">=</span> <span class="n">TypeName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">asType</span><span class="o">());</span>
            <span class="n">FieldViewBinding</span> <span class="n">fieldViewBinding</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FieldViewBinding</span><span class="o">(</span><span class="n">elementName</span><span class="o">,</span> <span class="n">typeName</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="n">builderClass</span><span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">fieldViewBinding</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 解析所有LISTENERS：方法上的事件注解</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Annotation</span><span class="o">&gt;</span> <span class="n">annotationClass</span> <span class="o">:</span> <span class="n">LISTENERS</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">element</span> <span class="o">:</span> <span class="n">roundEnv</span><span class="o">.</span><span class="na">getElementsAnnotatedWith</span><span class="o">(</span><span class="n">annotationClass</span><span class="o">))</span> <span class="o">{</span>
                <span class="c1">// 方法元素</span>
                <span class="n">ExecutableElement</span> <span class="n">executableElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">ExecutableElement</span><span class="o">)</span> <span class="n">element</span><span class="o">;</span>
                <span class="c1">// 类元素(持有者元素)</span>
                <span class="n">TypeElement</span> <span class="n">enclosingElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">TypeElement</span><span class="o">)</span> <span class="n">element</span><span class="o">.</span><span class="na">getEnclosingElement</span><span class="o">();</span>
                <span class="c1">// 方法的注解对象</span>
                <span class="n">Annotation</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">annotationClass</span><span class="o">);</span>
                <span class="c1">// 注解的value方法</span>
                <span class="n">Method</span> <span class="n">annotationValue</span> <span class="o">=</span> <span class="n">annotationClass</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"value"</span><span class="o">);</span>
                <span class="c1">// 获取注解的ids</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">ids</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">[])</span> <span class="n">annotationValue</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">annotation</span><span class="o">);</span>
                <span class="c1">// 方法名称</span>
                <span class="n">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">executableElement</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
                <span class="c1">// 注解的注解</span>
                <span class="n">ListenerClass</span> <span class="n">listenerClass</span> <span class="o">=</span> <span class="n">annotationClass</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">ListenerClass</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="c1">// 注解注解的参数</span>
                <span class="n">ListenerMethod</span> <span class="n">listenerMethod</span> <span class="o">=</span> <span class="n">listenerClass</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
                <span class="c1">// 方法参数</span>
                <span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">VariableElement</span><span class="o">&gt;</span> <span class="n">methodParameters</span> <span class="o">=</span> <span class="n">executableElement</span><span class="o">.</span><span class="na">getParameters</span><span class="o">();</span>

                <span class="n">Parameter</span><span class="o">[]</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="na">NONE</span><span class="o">;</span>
                <span class="c1">// 真实方法参数</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">methodParameters</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">parameters</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Parameter</span><span class="o">[</span><span class="n">methodParameters</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
                    <span class="c1">// 注解的注解中的参数类型</span>
                    <span class="n">String</span><span class="o">[]</span> <span class="n">parameterTypes</span> <span class="o">=</span> <span class="n">listenerMethod</span><span class="o">.</span><span class="na">parameters</span><span class="o">();</span>

                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">methodParameters</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">VariableElement</span> <span class="n">methodParameter</span> <span class="o">=</span> <span class="n">methodParameters</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                        <span class="c1">// 方法参数</span>
                        <span class="n">TypeMirror</span> <span class="n">methodParameterType</span> <span class="o">=</span> <span class="n">methodParameter</span><span class="o">.</span><span class="na">asType</span><span class="o">();</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">methodParameterType</span> <span class="k">instanceof</span> <span class="n">TypeVariable</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">TypeVariable</span> <span class="n">typeVariable</span> <span class="o">=</span> <span class="o">(</span><span class="n">TypeVariable</span><span class="o">)</span> <span class="n">methodParameterType</span><span class="o">;</span>
                            <span class="n">methodParameterType</span> <span class="o">=</span> <span class="n">typeVariable</span><span class="o">.</span><span class="na">getUpperBound</span><span class="o">();</span>
                            <span class="n">messager</span><span class="o">.</span><span class="na">printMessage</span><span class="o">(</span><span class="n">Diagnostic</span><span class="o">.</span><span class="na">Kind</span><span class="o">.</span><span class="na">ERROR</span><span class="o">,</span> <span class="o">((</span><span class="n">TypeVariable</span><span class="o">)</span> <span class="n">methodParameterType</span><span class="o">).</span><span class="na">asElement</span><span class="o">().</span><span class="na">getSimpleName</span><span class="o">());</span>
                        <span class="o">}</span>
                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">parameterTypes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="c1">// 封装了真实参数的位置，类型</span>
                            <span class="n">parameters</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Parameter</span><span class="o">(</span><span class="n">j</span><span class="o">,</span> <span class="n">TypeName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">methodParameterType</span><span class="o">));</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// name:方法名 parameters:方法参数parameter required:方法上是否有Optional注解（一般不会有，所以为true）</span>
                <span class="c1">// 一般都是true，我们这里没有给注解设置Optional注解</span>
                <span class="n">MethodViewBinding</span> <span class="n">methodViewBinding</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MethodViewBinding</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">parameters</span><span class="o">),</span> <span class="kc">true</span><span class="o">);</span>
                <span class="n">VBinderBuilder</span> <span class="n">builderClass</span> <span class="o">=</span> <span class="n">getOrCreateTargetClass</span><span class="o">(</span><span class="n">vBinderBuilderMap</span><span class="o">,</span> <span class="n">enclosingElement</span><span class="o">);</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">:</span> <span class="n">ids</span><span class="o">){</span>
                    <span class="n">builderClass</span><span class="o">.</span><span class="na">addMethod</span><span class="o">(</span><span class="n">id</span><span class="o">,</span><span class="n">listenerClass</span><span class="o">,</span><span class="n">listenerMethod</span><span class="o">,</span><span class="n">methodViewBinding</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">vBinderBuilderMap</span><span class="o">;</span>
    <span class="o">}</span></code></pre></figure>

<h2 id="viewbinder">ViewBinder绑定帮助类生成</h2>

<p>根据上一篇的实现步骤，我们生成一个实现ViewBinder接口，及其方法，实现控件初始化的类已经不是一件难事，现在最大的困难就是如何通过JavaPoet实现类似下面的代码：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">        <span class="n">view</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">DebouncingOnClickListener</span><span class="o">()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="n">doClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">target</span><span class="o">.</span><span class="na">click</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">});</span></code></pre></figure>

<p>根据butterKnife代码我给出具体的解决步骤：
以@OnLongClick为例：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// new DebouncingOnClickListener()</span>
<span class="c1">// 这里就是一个空接口以及一个父类</span>
<span class="n">TypeSpec</span><span class="o">.</span><span class="na">Builder</span> <span class="n">interfaceEventBuilder</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="o">.</span><span class="na">anonymousClassBuilder</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
						<span class="o">.</span><span class="na">superclass</span><span class="o">(</span><span class="n">ClassName</span><span class="o">.</span><span class="na">bestGuess</span><span class="o">(</span><span class="n">keyListenerClass</span><span class="o">.</span><span class="na">type</span><span class="o">()));</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 这里代表的是 方法：public void doClick</span>
<span class="n">MethodSpec</span><span class="o">.</span><span class="na">Builder</span> <span class="n">interfaceMethodBuilder</span> <span class="o">=</span> <span class="n">MethodSpec</span><span class="o">.</span><span class="na">methodBuilder</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">())</span>
								<span class="o">.</span><span class="na">addAnnotation</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
								<span class="o">.</span><span class="na">addModifiers</span><span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">PUBLIC</span><span class="o">)</span>
								<span class="o">.</span><span class="na">returns</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">returnType</span><span class="o">()));</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 第一个参数  是参数类型  第一个参数是参数名(p0 p1 p2 ...)</span>
<span class="c1">// 方法中的参数(View v)</span>
<span class="n">interfaceMethodBuilder</span><span class="o">.</span><span class="na">addParameter</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">(</span><span class="n">parameterTypes</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="s">"p"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 调用target的对应方法：target.click(v);</span>
<span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"target.$L("</span><span class="o">,</span> <span class="n">methodViewBinding</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span></code></pre></figure>

<p>整个方法的生成代码如下：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addMethodBindings</span><span class="p">(</span><span class="n">MethodSpec</span><span class="o">.</span><span class="na">Builder</span> <span class="n">resultBuilder</span><span class="o">,</span> <span class="n">VBinderData</span> <span class="n">vbinderData</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">ListenerClass</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">ListenerMethod</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">MethodViewBinding</span><span class="o">&gt;&gt;&gt;</span> <span class="n">listenerMethodBindings</span> <span class="o">=</span> <span class="n">vbinderData</span><span class="o">.</span><span class="na">getMethodBindings</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">listenerMethodBindings</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">Set</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">ListenerClass</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">ListenerMethod</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">MethodViewBinding</span><span class="o">&gt;&gt;&gt;&gt;</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">listenerMethodBindings</span><span class="o">.</span><span class="na">entrySet</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">ListenerClass</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">ListenerMethod</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">MethodViewBinding</span><span class="o">&gt;&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">entries</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ListenerClass</span> <span class="n">keyListenerClass</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">ListenerMethod</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">MethodViewBinding</span><span class="o">&gt;&gt;</span> <span class="n">methodValue</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
            <span class="c1">// 创建接口实体类(空匿名类的接口父类)</span>
            <span class="c1">// anonymous 匿名</span>
            <span class="n">TypeSpec</span><span class="o">.</span><span class="na">Builder</span> <span class="n">interfaceEventBuilder</span> <span class="o">=</span> <span class="n">TypeSpec</span><span class="o">.</span><span class="na">anonymousClassBuilder</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">superclass</span><span class="o">(</span><span class="n">ClassName</span><span class="o">.</span><span class="na">bestGuess</span><span class="o">(</span><span class="n">keyListenerClass</span><span class="o">.</span><span class="na">type</span><span class="o">()));</span>
            <span class="c1">// 根据ListenerClass 中的 参数 生成代码</span>
            <span class="n">ListenerMethod</span> <span class="n">method</span> <span class="o">=</span> <span class="n">keyListenerClass</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">method</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">MethodSpec</span><span class="o">.</span><span class="na">Builder</span> <span class="n">interfaceMethodBuilder</span> <span class="o">=</span> <span class="n">MethodSpec</span><span class="o">.</span><span class="na">methodBuilder</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">())</span>
                        <span class="o">.</span><span class="na">addAnnotation</span><span class="o">(</span><span class="n">Override</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">addModifiers</span><span class="o">(</span><span class="n">Modifier</span><span class="o">.</span><span class="na">PUBLIC</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">returns</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">returnType</span><span class="o">()));</span>
                <span class="n">String</span><span class="o">[]</span> <span class="n">parameterTypes</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">parameters</span><span class="o">();</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parameterTypes</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="c1">// 第一个参数  是参数类型  第一个参数是参数名(p0 p1 p2 ...)</span>
                    <span class="n">interfaceMethodBuilder</span><span class="o">.</span><span class="na">addParameter</span><span class="o">(</span><span class="n">bestGuess</span><span class="o">(</span><span class="n">parameterTypes</span><span class="o">[</span><span class="n">i</span><span class="o">]),</span> <span class="s">"p"</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="kt">boolean</span> <span class="n">hasReturnType</span> <span class="o">=</span> <span class="o">!</span><span class="s">"void"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">returnType</span><span class="o">());</span>
                <span class="c1">// 代码块</span>
                <span class="n">CodeBlock</span><span class="o">.</span><span class="na">Builder</span> <span class="n">codeBuilder</span> <span class="o">=</span> <span class="n">CodeBlock</span><span class="o">.</span><span class="na">builder</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">hasReturnType</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"return "</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// 一个id对应多个ListenerMethod</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">methodValue</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">for</span> <span class="o">(</span><span class="n">MethodViewBinding</span> <span class="n">methodViewBinding</span> <span class="o">:</span> <span class="n">methodValue</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">method</span><span class="o">))</span> <span class="o">{</span>
                        <span class="c1">// 调用target的对应方法</span>
                        <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"target.$L("</span><span class="o">,</span> <span class="n">methodViewBinding</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
                        <span class="n">List</span><span class="o">&lt;</span><span class="n">Parameter</span><span class="o">&gt;</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">methodViewBinding</span><span class="o">.</span><span class="na">getParameters</span><span class="o">();</span>
                        <span class="c1">// MethodListener注解的参数</span>
                        <span class="n">String</span><span class="o">[]</span> <span class="n">methodParameters</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">parameters</span><span class="o">();</span>
                        <span class="c1">// 优化了每次parameters.size()</span>
                        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">count</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                                <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">", "</span><span class="o">);</span>
                            <span class="o">}</span>
                            <span class="n">Parameter</span> <span class="n">parameter</span> <span class="o">=</span> <span class="n">parameters</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                            <span class="kt">int</span> <span class="n">listenerPosition</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="na">getListenerPosition</span><span class="o">();</span>
                            <span class="c1">// 类型不一样，范型万能转换</span>
                            <span class="k">if</span> <span class="o">(</span><span class="n">parameter</span><span class="o">.</span><span class="na">requiresCast</span><span class="o">(</span><span class="n">methodParameters</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                                <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"finder.&lt;$T&gt;castParam(p$L, $S, $L, $S, $L)\n"</span><span class="o">,</span> <span class="n">parameter</span><span class="o">.</span><span class="na">getType</span><span class="o">(),</span>
                                        <span class="n">listenerPosition</span><span class="o">,</span> <span class="n">method</span><span class="o">.</span><span class="na">name</span><span class="o">(),</span> <span class="n">listenerPosition</span><span class="o">,</span> <span class="n">methodViewBinding</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">i</span><span class="o">);</span>
                            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                                <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"p$L"</span><span class="o">,</span> <span class="n">listenerPosition</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                        <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">");\n"</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">hasReturnType</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">codeBuilder</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"$L;\n"</span><span class="o">,</span> <span class="n">method</span><span class="o">.</span><span class="na">defaultReturn</span><span class="o">());</span>
                <span class="o">}</span>
                <span class="n">interfaceMethodBuilder</span><span class="o">.</span><span class="na">addCode</span><span class="o">(</span><span class="n">codeBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
                <span class="n">interfaceEventBuilder</span><span class="o">.</span><span class="na">addMethod</span><span class="o">(</span><span class="n">interfaceMethodBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="c1">// 如果不是view类型，需要强转</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">APTConfig</span><span class="o">.</span><span class="na">VIEW_TYPE</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">keyListenerClass</span><span class="o">.</span><span class="na">targetType</span><span class="o">()))</span> <span class="o">{</span>
                <span class="c1">// targetType不是view的时候需要强转</span>
                <span class="n">resultBuilder</span><span class="o">.</span><span class="na">addStatement</span><span class="o">(</span><span class="s">"(($T) view).$L($L)"</span><span class="o">,</span> <span class="n">bestGuess</span><span class="o">(</span><span class="n">keyListenerClass</span><span class="o">.</span><span class="na">targetType</span><span class="o">()),</span>
                        <span class="n">keyListenerClass</span><span class="o">.</span><span class="na">setter</span><span class="o">(),</span> <span class="n">interfaceEventBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="c1">// view.setOnClickListener(对象)</span>
                <span class="n">resultBuilder</span><span class="o">.</span><span class="na">addStatement</span><span class="o">(</span><span class="s">"view.$L($L)"</span><span class="o">,</span> <span class="n">keyListenerClass</span><span class="o">.</span><span class="na">setter</span><span class="o">(),</span> <span class="n">interfaceEventBuilder</span><span class="o">.</span><span class="na">build</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></figure>

<p>其他的具体步骤大家看下demo</p>

<h2 id="section-4">总结</h2>
<p>代码这个东西，看跟敲是两种体验，也是两种结果，以后会继续坚持，总结下从butterKnife框架细节中我学到的知识：</p>

<ul>
  <li>BitSet : java中提供的此神器用来记录我对一组数据的改动与否</li>
  <li>@Retention(RUNTIME) ：注解的注解是需要runtime的，即便仅在编译期读取，RetentionPolicy.CLASS也是不奏效的，必需是RetentionPolicy.RUNTIME</li>
  <li>for (int i = 0, count = parameters.size(); i &lt; count; i++) : 省去每次遍历调用parameters.size()的同时，又优雅的初始化了count并附上了想要的值(智慧而优雅)</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>注解初始化控件(ButterKnife方式)<上></title>
	  <link>//butterknifedemo01</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-04-05T00:00:00+08:00</pubDate>
	  <guid>//butterknifedemo01</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>在学习了XUtils的注入方式之后，看了下ButterKnife的实现方式，结果发现完全不一样，然后借鉴网上的博客，结果发现用的都是Eclipse以及旧版本的ButterKnife进行实现的。</p>

  <p>这里我用AndroidStudio根据ButterKnife的版本进行了实现。</p>
</blockquote>

<p>文字枯燥，还是先看下butterknife的module图：
<img src="http://img.blog.csdn.net/20160401092206024" alt="这里写图片描述" /></p>

<p>先看下ButterKnife中生成的java代码（看看骚包的注释 Do not modify!）</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Generated code from Butter Knife. Do not modify!</span>
<span class="c1">// Generated code from Butter Knife. Do not modify!</span>
<span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">example</span><span class="o">.</span><span class="na">butterknife</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.widget.AdapterView</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">butterknife.ButterKnife</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">butterknife.internal.DebouncingOnClickListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">butterknife.internal.Finder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">butterknife.internal.Utils</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">butterknife.internal.ViewBinder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.IllegalStateException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.Object</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.Override</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.lang.SuppressWarnings</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleActivity</span><span class="err">$</span><span class="n">$ViewBinder</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SimpleActivity</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">ViewBinder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="n">bind</span><span class="o">(</span><span class="kd">final</span> <span class="n">Finder</span> <span class="n">finder</span><span class="o">,</span> <span class="kd">final</span> <span class="n">T</span> <span class="n">target</span><span class="o">,</span> <span class="n">Object</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Unbinder</span> <span class="n">unbinder</span> <span class="o">=</span> <span class="n">createUnbinder</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
    <span class="n">View</span> <span class="n">view</span><span class="o">;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968576</span><span class="o">,</span> <span class="s">"field 'title'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">title</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="mi">2130968576</span><span class="o">,</span> <span class="s">"field 'title'"</span><span class="o">);</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968577</span><span class="o">,</span> <span class="s">"field 'subtitle'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">subtitle</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="mi">2130968577</span><span class="o">,</span> <span class="s">"field 'subtitle'"</span><span class="o">);</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968578</span><span class="o">,</span> <span class="s">"field 'hello', method 'sayHello', and method 'sayGetOffMe'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">hello</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="mi">2130968578</span><span class="o">,</span> <span class="s">"field 'hello'"</span><span class="o">);</span>
    <span class="n">unbinder</span><span class="o">.</span><span class="na">view2130968578</span> <span class="o">=</span> <span class="n">view</span><span class="o">;</span>
    <span class="n">view</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">DebouncingOnClickListener</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="n">doClick</span><span class="o">(</span><span class="n">View</span> <span class="n">p0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">target</span><span class="o">.</span><span class="na">sayHello</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">});</span>
    <span class="n">view</span><span class="o">.</span><span class="na">setOnLongClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">View</span><span class="o">.</span><span class="na">OnLongClickListener</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">onLongClick</span><span class="o">(</span><span class="n">View</span> <span class="n">p0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">target</span><span class="o">.</span><span class="na">sayGetOffMe</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">});</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968579</span><span class="o">,</span> <span class="s">"field 'listOfThings' and method 'onItemClick'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">listOfThings</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="mi">2130968579</span><span class="o">,</span> <span class="s">"field 'listOfThings'"</span><span class="o">);</span>
    <span class="n">unbinder</span><span class="o">.</span><span class="na">view2130968579</span> <span class="o">=</span> <span class="n">view</span><span class="o">;</span>
    <span class="o">((</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;)</span> <span class="n">view</span><span class="o">).</span><span class="na">setOnItemClickListener</span><span class="o">(</span><span class="k">new</span> <span class="n">AdapterView</span><span class="o">.</span><span class="na">OnItemClickListener</span><span class="o">()</span> <span class="o">{</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="n">onItemClick</span><span class="o">(</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;</span> <span class="n">p0</span><span class="o">,</span> <span class="n">View</span> <span class="n">p1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p2</span><span class="o">,</span> <span class="kt">long</span> <span class="n">p3</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">target</span><span class="o">.</span><span class="na">onItemClick</span><span class="o">(</span><span class="n">p2</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">});</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968580</span><span class="o">,</span> <span class="s">"field 'footer'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">footer</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">castView</span><span class="o">(</span><span class="n">view</span><span class="o">,</span> <span class="mi">2130968580</span><span class="o">,</span> <span class="s">"field 'footer'"</span><span class="o">);</span>
    <span class="n">target</span><span class="o">.</span><span class="na">headerViews</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="na">listOf</span><span class="o">(</span>
        <span class="n">finder</span><span class="o">.&lt;</span><span class="n">View</span><span class="o">&gt;</span><span class="n">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968576</span><span class="o">,</span> <span class="s">"field 'headerViews'"</span><span class="o">),</span> 
        <span class="n">finder</span><span class="o">.&lt;</span><span class="n">View</span><span class="o">&gt;</span><span class="n">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968577</span><span class="o">,</span> <span class="s">"field 'headerViews'"</span><span class="o">),</span> 
        <span class="n">finder</span><span class="o">.&lt;</span><span class="n">View</span><span class="o">&gt;</span><span class="n">findRequiredView</span><span class="o">(</span><span class="n">source</span><span class="o">,</span> <span class="mi">2130968578</span><span class="o">,</span> <span class="s">"field 'headerViews'"</span><span class="o">));</span>
    <span class="n">target</span><span class="o">.</span><span class="na">unbinder</span> <span class="o">=</span> <span class="n">unbinder</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
  <span class="kd">protected</span> <span class="o">&lt;</span><span class="n">U</span> <span class="kd">extends</span> <span class="n">Unbinder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">U</span> <span class="n">createUnbinder</span><span class="o">(</span><span class="n">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">U</span><span class="o">)</span> <span class="k">new</span> <span class="n">Unbinder</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">"unchecked"</span><span class="o">)</span>
  <span class="kd">protected</span> <span class="o">&lt;</span><span class="n">U</span> <span class="kd">extends</span> <span class="n">Unbinder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="n">U</span> <span class="n">accessUnbinder</span><span class="o">(</span><span class="n">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">U</span><span class="o">)</span> <span class="n">target</span><span class="o">.</span><span class="na">unbinder</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Unbinder</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">SimpleActivity</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="n">ButterKnife</span><span class="o">.</span><span class="na">ViewUnbinder</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">T</span> <span class="n">target</span><span class="o">;</span>

    <span class="n">View</span> <span class="n">view2130968578</span><span class="o">;</span>

    <span class="n">View</span> <span class="n">view2130968579</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="n">Unbinder</span><span class="o">(</span><span class="n">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="n">unbind</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">target</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">"Bindings already cleared."</span><span class="o">);</span>
      <span class="n">unbind</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
      <span class="n">target</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="n">unbind</span><span class="o">(</span><span class="n">T</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">target</span><span class="o">.</span><span class="na">title</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">target</span><span class="o">.</span><span class="na">subtitle</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">view2130968578</span><span class="o">.</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
      <span class="n">view2130968578</span><span class="o">.</span><span class="na">setOnLongClickListener</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
      <span class="n">target</span><span class="o">.</span><span class="na">hello</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">((</span><span class="n">AdapterView</span><span class="o">&lt;?&gt;)</span> <span class="n">view2130968579</span><span class="o">).</span><span class="na">setOnItemClickListener</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
      <span class="n">target</span><span class="o">.</span><span class="na">listOfThings</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">target</span><span class="o">.</span><span class="na">footer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">target</span><span class="o">.</span><span class="na">headerViews</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="n">target</span><span class="o">.</span><span class="na">unbinder</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="butterknifeviewdemohttpdownloadcsdnnetdetailyuanyang59179478759"><a href="http://download.csdn.net/detail/yuanyang5917/9478759">ButterKnifeView注入demo(简单易学)</a></h2>

<blockquote>
  <p>这个demo的代码生成，以及接口思想，以及调用生成代码的思想，都是借鉴ButterKnife的</p>
</blockquote>

<blockquote>
  <p>我先简单实现了ButterKnife的View注入，去除了ButterKnife繁琐的编译校验，本篇也没有添加事件注入(下一篇会有)</p>
</blockquote>

<h3 id="xutils--butterknife">XUtils 与 ButterKnife实现方式的区别</h3>
<p>上篇XUtils实现注解初始化用的是反射 +  动态代理</p>

<blockquote>
  <p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
</blockquote>

<h2 id="apt">APT</h2>
<p>而ButterKnife使用的是APT (Annotation Processing Tool )
&gt;apt是一个命令行工具，与之配套的还有一套用来描述程序语义结构的Mirror API。Mirror API（com.sun.mirror.*）描述的是程序在编译时刻的静态结构。通过Mirror API可以获取到被注解的Java类型元素的信息，从而提供相应的处理逻辑。具体的处理工作交给apt工具来完成。编写注解处理器的核心是AnnotationProcessorFactory和AnnotationProcessor两个接口。后者表示的是注解处理器，而前者则是为某些注解类型创建注解处理器的工厂。</p>

<ol>
  <li>
    <p>APT配置
需要再compiler Module中的main.resources.META-INF.services下新建文本java.annotation.processing.Processor，在文本内添加Processor全名(我的Processor是com.example.MyProcessor)
或者直接在Processor实现类上@AutoService(Processor.class)(我还没实现成功)
需要在build.gradle里面配置APT插件(classpath ‘com.neenbedankt.gradle.plugins:android-apt:1.8’)</p>
  </li>
  <li>
    <p>Processor类
(1)JAVA1.6以后的Processor实现类都需要extends AbstractProcessor
(2)Processor类需要指定其处理的注解
方式一(类上注解)：@SupportedAnnotationTypes(“com.example.AptBetter”)
方式二(重写方法)：getSupportedAnnotationTypes
(4)process方法，编译时进入的主方法，用于分析注解信息，以及生成代码
(4)Processor都要指定版本
一般获取最新的版本：</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Override</span>
<span class="kd">public</span> <span class="n">SourceVersion</span> <span class="nf">getSupportedSourceVersion</span><span class="p">(</span><span class="o">)</span> <span class="o">{</span>
<span class="k">return</span> <span class="n">SourceVersion</span><span class="o">.</span><span class="na">latestSupported</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<ol>
  <li>Process内部元素
ProcessingEnvironment：编译环境</li>
</ol>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 用于生成代码</span>
<span class="n">Filer</span> <span class="n">filer</span> <span class="o">=</span> <span class="n">processingEnv</span><span class="o">.</span><span class="na">getFiler</span><span class="o">();</span>
<span class="c1">// 用于编译时给图</span>
<span class="n">Messager</span> <span class="n">messager</span> <span class="o">=</span> <span class="n">processingEnv</span><span class="o">.</span><span class="na">getMessager</span><span class="o">();</span>
<span class="c1">// Element工具，可以获取包名</span>
<span class="n">Elements</span> <span class="n">elementUtils</span> <span class="o">=</span> <span class="n">processingEnv</span><span class="o">.</span><span class="na">getElementUtils</span><span class="o">();</span></code></pre></figure>

<p>RoundEnvironment：回合环境(国内暂时没有固定的说法，暂且定义为元素环境)
因为可以从中获取到5大Element</p>

<figure class="highlight"><pre><code class="language-ios" data-lang="ios">Mirror的五大Element
PackageElement 包元素
TypeElement     类元素
VariableElement  变量元素
ExecutableElement  方法元素
TypeParameterElement  参数元素
通过这些元素，可以获取到元素的各种信息：注解、类型、名称等等</code></pre></figure>

<p>其中TypeMirror.accept这个我还很模糊，有明白的请赐教</p>

<ol>
  <li>代码生成器
这里有一个大杀器：JavaPoet (Java诗人) 也是Jake Wharton所参与的著作之一，膜拜Jake Wharthon，膜拜Square。大家可以直接到Github上搜索JavaPoet。</li>
</ol>

<h2 id="section">运行期流程</h2>

<p><img src="http://img.blog.csdn.net/20160401155957286" alt="这里写图片描述" /></p>

<p>主要是通过Butterknife调用生成的Activity$$ViewBinder类中的bind方法，实现了控件初始化、时间注入</p>

<h3 id="question-">Question :</h3>
<p>(1)在代码编写的时候类都还没有生成，那么如何获取其对象
answer:通过反，Activity也是通过这种方式生成的</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">viewBindingClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">clsName</span> <span class="o">+</span> <span class="s">"$$ViewBinder"</span><span class="o">);</span>
<span class="n">ViewBinder</span> <span class="n">viewBinder</span> <span class="o">=</span> <span class="o">(</span><span class="n">ViewBinder</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;)</span> <span class="n">viewBindingClass</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span></code></pre></figure>

<p>(2)如何能调用bind方法，如何能强转，因为生成的代码实现了ViewBinder接口，接口的力量啊！针对接口编程！</p>

<h2 id="compiler">分析compiler</h2>

<p>思路分析：
（1）一个类、一个内部类生成一个同包下的名称相似的IOC容器类
（2）一类中会有很多控件需要初始化，那么我们把一个类、一个内部类所提供的多个控件信息、类名、包名、id封装成一个Bean：BindingClass(ButterKnife除了可以给控件初始化之外，还可以给各种资源初始化，甚至可以解绑UnBinding，ButterKnife中把每种类型都封装成一种Bean，这里我们紧紧做了View的初始化),我们这里BindingClass里面仅仅放的是FieldViewBinding
（3）一个需要初始化的类对应一个BindingClass(含有很多FieldViewBinding)，对应生成一个ViewBinder，那么生成代码的逻辑我们可以放在Compiler中的BindingClass，作为其内部类(可以直接获取BindingClass中的类名、包名、控件集合)</p>

<p><img src="http://img.blog.csdn.net/20160404004902680" alt="这里写图片描述" /></p>

<h2 id="section-1">编译器读信息</h2>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 所有AptBetter的成员变量</span>
        <span class="n">Set</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Element</span><span class="o">&gt;</span> <span class="n">elementsAnnotatedWith</span> <span class="o">=</span> <span class="n">roundEnv</span><span class="o">.</span><span class="na">getElementsAnnotatedWith</span><span class="o">(</span><span class="n">AptBetter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="c1">// 元素归类</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">Element</span> <span class="n">element</span> <span class="o">:</span> <span class="n">elementsAnnotatedWith</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">TypeElement</span> <span class="n">typeElement</span> <span class="o">=</span> <span class="o">(</span><span class="n">TypeElement</span><span class="o">)</span> <span class="n">element</span><span class="o">.</span><span class="na">getEnclosingElement</span><span class="o">();</span>
            <span class="n">BindingClass</span> <span class="n">bindingClass</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">allBindEvent</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">typeElement</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">bindingClass</span> <span class="o">=</span> <span class="n">allBindEvent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">typeElement</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">String</span> <span class="n">targetType</span> <span class="o">=</span> <span class="n">typeElement</span><span class="o">.</span><span class="na">getQualifiedName</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
                <span class="n">String</span> <span class="n">classPackage</span> <span class="o">=</span> <span class="n">getPackageName</span><span class="o">(</span><span class="n">typeElement</span><span class="o">);</span>
                <span class="c1">// packageName$className$$ViewBinder</span>
                <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">getClassName</span><span class="o">(</span><span class="n">typeElement</span><span class="o">,</span> <span class="n">classPackage</span><span class="o">)</span> <span class="o">+</span> <span class="n">SUFFIX</span><span class="o">;</span>

                <span class="n">bindingClass</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BindingClass</span><span class="o">(</span><span class="n">classPackage</span><span class="o">,</span> <span class="n">className</span><span class="o">,</span> <span class="n">targetType</span><span class="o">);</span>
                <span class="n">allBindEvent</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">typeElement</span><span class="o">,</span> <span class="n">bindingClass</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">AptBetter</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">value</span><span class="o">();</span>
            <span class="n">String</span> <span class="n">elementName</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
            <span class="n">TypeName</span> <span class="n">typeName</span> <span class="o">=</span> <span class="n">TypeName</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">element</span><span class="o">.</span><span class="na">asType</span><span class="o">());</span>
            <span class="n">bindingClass</span><span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="k">new</span> <span class="n">FieldViewBinding</span><span class="o">(</span><span class="n">elementName</span><span class="o">,</span> <span class="n">typeName</span><span class="o">,</span> <span class="n">value</span><span class="o">));</span>
        <span class="o">}</span></code></pre></figure>

<h2 id="javapoet">代码生成(JavaPoet)</h2>
<p>这里是用的是JavaPoet，下面是教程地址：</p>

<ul>
  <li><a href="https://github.com/square/javapoet">JavaPoet In Github</a></li>
  <li><a href="http://p.codekk.com/detail/Android/square/javapoet">JavaPoet博客教程</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Android控件注解IOC注入(XUtils实现方式)</title>
	  <link>//iocxutils</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-03-29T00:00:00+08:00</pubDate>
	  <guid>//iocxutils</guid>
	  <description><![CDATA[
	     <h2 id="xutils">注解初始化控件(XUtils方式)</h2>

<blockquote>
  <p><a href="http://download.csdn.net/detail/yuanyang5917/9477513">DEMO链接地址</a></p>
</blockquote>

<blockquote>
  <p>在第一次潭州教育的公开课上接触了这个框架的讲解，我动手研究了一下，结果一出手就停不下来，先后被我碰上了（<a href="http://tech.glowing.com/cn/dynamic-android-programming/">Glow公司的技术博客——动态Android编程</a> ）、从几个大牛的博客（学到了github pages + Jekyll 免费制作博客网站）<br />
我发现不写博客，很多东西就会忘记(代码如何上传到jcenter我已经忘记了)<br />
Just Do it!真的会有意想不到的收获！</p>
</blockquote>

<p><img src="http://img.blog.csdn.net/20160329132113633" alt="实现效果" />
 1. IOC概念介绍
http://www.cnblogs.com/qqlin/archive/2012/10/09/2707075.html我是从这边文章学习的IOC概念的，写的浅显易懂</p>

<ul>
  <li>控件反转(IOC)：创建何种对象的控制权，转移到第三方</li>
  <li>依赖注入(DI)：是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</li>
  <li>IOC与DI之间的关系：DI是一种IOC的具体思想，(编译运行期，动态注入依赖关系)；使用配置文件实现依赖关系的配置也是一种IOC思想（依赖拖拽）。</li>
  <li>约定优于配置 这个是什么鬼？？</li>
  <li>依赖注入／依赖查找／依赖拖拽
    <ul>
      <li>依赖拖拽是通过对注入对象的集中配置实现的</li>
      <li>依赖查找是在业务组件代码中进行的（EJB和Apache Avalon ）
        <ol>
          <li>XUtils的实现方式XUtils实际上是通过 注解 ＋ 反射 ＋ 动态代理实现的。</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h2 id="layout">layout文件注入：</h2>
<ul>
  <li>使用：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@ContentViewInject</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MainActivity</span> <span class="kd">extends</span> <span class="n">AppCompatActivity</span></code></pre></figure>

<ul>
  <li>注解：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span><span class="c1">// 使用对象：类</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span><span class="c1">// 生命范围：运行期</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">ContentViewInject</span> <span class="o">{</span>    
	<span class="kt">int</span> <span class="n">value</span><span class="o">();</span><span class="c1">// 存放布局id</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>注入代码：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">injectLayout</span><span class="p">(</span><span class="n">Activity</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// UIClz</span>
            <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Context</span><span class="o">&gt;</span> <span class="n">uiClass</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
            <span class="c1">// 类上的注解</span>
            <span class="n">ContentViewInject</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">ContentViewInject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 注解中的layout id值</span>
                <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
                <span class="c1">// 通过反射使用activity中的setContentView方法进行 布局设置</span>
                <span class="c1">// 局限性：这个方法仅仅适用于activity</span>
                <span class="n">Method</span> <span class="n">setContentView</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"setContentView"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="n">setContentView</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></figure>

<h2 id="section">控件注入：</h2>

<ul>
  <li>使用：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@ViewInject</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">)</span>
<span class="n">TextView</span> <span class="n">textView</span><span class="o">;</span>
<span class="o">......</span>
  <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="n">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">TurInject</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">textView</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="s">"徕帝嘎嘎"</span><span class="o">);</span>
    <span class="o">}</span></code></pre></figure>

<ul>
  <li>注解：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">ViewInject</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<ul>
  <li>注入：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">injectViews</span><span class="p">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Context</span><span class="o">&gt;</span> <span class="n">uiClass</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
            <span class="c1">// 获取成员变量</span>
            <span class="n">Field</span><span class="o">[]</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getDeclaredFields</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">Field</span> <span class="n">field</span> <span class="o">:</span> <span class="n">fields</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ViewInject</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">ViewInject</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
                    <span class="n">Method</span> <span class="n">findViewById</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"findViewById"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                    <span class="n">Object</span> <span class="n">invoke</span> <span class="o">=</span> <span class="n">findViewById</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
                    <span class="c1">// 设置允许访问</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
                    <span class="n">field</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">invoke</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></figure>

<h2 id="section-1">事件注入</h2>

<ul>
  <li>使用代码：</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="nd">@ClickEvent</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="o">{</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">},</span> <span class="n">type</span> <span class="o">=</span> <span class="n">View</span><span class="o">.</span><span class="na">OnClickListener</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">ccClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="s">"ccClick"</span><span class="o">,</span> <span class="n">Toast</span><span class="o">.</span><span class="na">LENGTH_LONG</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@ClickEvent</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="o">{</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">textView</span><span class="o">},</span> <span class="n">type</span> <span class="o">=</span> <span class="n">View</span><span class="o">.</span><span class="na">OnLongClickListener</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">longClick</span><span class="o">(</span><span class="n">View</span> <span class="n">view</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Toast</span><span class="o">.</span><span class="na">makeText</span><span class="o">(</span><span class="n">getBaseContext</span><span class="o">(),</span> <span class="s">"longClick"</span><span class="o">,</span> <span class="n">Toast</span><span class="o">.</span><span class="na">LENGTH_LONG</span><span class="o">).</span><span class="na">show</span><span class="o">();</span>
    <span class="o">}</span></code></pre></figure>

<ul>
  <li>注解</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">injectMethod</span><span class="p">(</span><span class="kd">final</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Class</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">Context</span><span class="o">&gt;</span> <span class="n">uiClass</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
            <span class="c1">// 获取所有的方法</span>
            <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getMethods</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kd">final</span> <span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">ClickEvent</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">ClickEvent</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                <span class="c1">// 塞选含有ClickEvent注解的方法</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">annotation</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
                    <span class="n">Class</span> <span class="n">type</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">type</span><span class="o">();</span>
                    <span class="c1">// 拿到控件</span>
                    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">viewId</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
                        <span class="c1">// 初始化控件</span>
                        <span class="n">Method</span> <span class="n">findViewById</span> <span class="o">=</span> <span class="n">uiClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"findViewById"</span><span class="o">,</span> <span class="kt">int</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
                        <span class="c1">// view</span>
                        <span class="kd">final</span> <span class="n">Object</span> <span class="n">viewObj</span> <span class="o">=</span> <span class="n">findViewById</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">viewId</span><span class="o">);</span>

                        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">viewClass</span> <span class="o">=</span> <span class="n">viewObj</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
                        <span class="c1">// setOnClickListener／setOnLongClickListener等等</span>
                        <span class="n">String</span> <span class="n">viewSetMethodName</span> <span class="o">=</span> <span class="s">"set"</span> <span class="o">+</span> <span class="n">type</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">();</span>
                        <span class="n">Method</span> <span class="n">viewMethod</span> <span class="o">=</span> <span class="n">viewClass</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">viewSetMethodName</span><span class="o">,</span> <span class="n">type</span><span class="o">);</span>

                        <span class="c1">// 动态代理就是针对 任意 一个对象的接口方法的  管理／拦截／AOP</span>
                        <span class="n">ViewEventInvocationHandler</span> <span class="n">viewEventInvocationHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ViewEventInvocationHandler</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">method</span><span class="o">);</span>
                        <span class="c1">//  type.getClassLoader ： 类加载器   new Class[]{type} ： type为接口类</span>
                        <span class="n">Object</span> <span class="n">eventInterfaceInstance</span> <span class="o">=</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]{</span><span class="n">type</span><span class="o">},</span> <span class="n">viewEventInvocationHandler</span><span class="o">);</span>
                        <span class="c1">// 动态代理  OnClickListener 中的</span>
                        <span class="c1">// 执行了setOnClickListener这个方法，那么在响应这个参数OnClickListener接口中的，onclick方法的时候会响应InvocationHandler中的invoke方法</span>
                        <span class="n">viewMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">viewObj</span><span class="o">,</span> <span class="n">eventInterfaceInstance</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">ViewEventInvocationHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="n">Context</span> <span class="n">context</span><span class="o">;</span>
        <span class="kd">private</span> <span class="n">Method</span> <span class="n">contentMethod</span><span class="o">;</span>

        <span class="kd">public</span> <span class="n">ViewEventInvocationHandler</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span> <span class="n">Method</span> <span class="n">contentMethod</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">context</span> <span class="o">=</span> <span class="n">context</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">contentMethod</span> <span class="o">=</span> <span class="n">contentMethod</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span> <span class="n">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
            <span class="c1">// method 为OnClickListener 中的 onClick</span>
            <span class="c1">// 系统调用参数接口中的 onClick方法的时候，会响应这个方法</span>
            <span class="c1">// 响应这个方法的时候我们需要响应(activity中被ClickEvent标记过的方法)</span>
            <span class="c1">// contentMethod 为activity中被 ClickEvent标记过的方法</span>
            <span class="n">contentMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></figure>

<p><a href="https://www.zhihu.com/question/20794107">知乎——代理、动态代理</a></p>

<ul>
  <li>主要用来做方法的增强，让你可以在不修改源码的情况下，增强一些方法，在方法执行前后做任何你想做的事情（甚至根本不去执行这个方法），因为在InvocationHandler的invoke方法中，你可以直接获取正在调用方法对应的Method对象，具体应用的话，比如可以添加调用日志，做事务控制等。</li>
  <li>还有一个有趣的作用是可以用作远程调用</li>
  <li>在某些情况下，一个客户不想或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
  <li>为其他对象提供一种代理以控制对这个对象的访问</li>
  <li>
    <p>动态代理的缺憾：Proxy已经设计得非常优美，但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏</p>

    <p>到这里呢，XUtils的布局注入、控件注入、事件注入就全部介绍完了！</p>
  </li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>技术进度</title>
	  <link>//technolog-schedule</link>
	  <author>LuckyTurbo</author>
	  <pubDate>2016-03-21T00:00:00+08:00</pubDate>
	  <guid>//technolog-schedule</guid>
	  <description><![CDATA[
	     <h2 id="section">公司技术探索</h2>
<ul>
  <li>连击</li>
  <li>连麦</li>
  <li>单元测试</li>
</ul>

<h2 id="studying">Studying</h2>

<ul>
  <li>潭州教育视频学习
 [(1)ImageLoader架构解析
 (2)插件式开发
 (3)视差动画]</li>
  <li>高焕堂网易云公开课
 ——Android中运用到的设计模式
 [13 Kinds of Design Pattern in Android Framwork]</li>
</ul>

<h2 id="section-1">已学完</h2>
<ul>
  <li>XUtils控件注入实现[注解＋反射＋动态代理]</li>
  <li>ButterKnife通过APT实现IOC的</li>
  <li>Android动画(5.0以下)</li>
</ul>

<hr />

<h3 id="section-2">学编程理念：</h3>

<blockquote>
  <ol>
    <li>高效的开发环境</li>
    <li>顺手的信息采集器和笔记本</li>
    <li>开阔视野，研究各平台间的差异与共同趋势</li>
    <li>学习一门新技术时，最大化它与你现有知识库的差异性</li>
    <li>全栈工程师，最快的捷径就是打造一款自己的产品</li>
    <li>Github上是否有出彩的项目、技术博客</li>
    <li>编程理念»&gt;技术本身</li>
    <li>优先学习思想、内力、公共基础</li>
  </ol>
</blockquote>

<h3 id="section-3">编程基础：</h3>

<ul>
  <li>[ ] 数据结构与算法</li>
  <li>[ ] 设计模式</li>
</ul>

<h3 id="java">java基础：</h3>

<ul>
  <li>[ ] 多线程</li>
  <li>[x] 反射</li>
  <li>[x] 注解
    <ul>
      <li>[x] APT</li>
    </ul>
  </li>
  <li>[ ] 自定义类加载器</li>
</ul>

<h3 id="android">android基础：</h3>

<ul>
  <li>[ ] 自定义view完全解析</li>
  <li>[x] 动画种类跟原理</li>
  <li>[x] 5.0材质设计</li>
  <li>[x] 6.0权限管理</li>
  <li>[ ] 源码解读</li>
</ul>

<h3 id="section-4">构架能力：</h3>

<ul>
  <li>[x] xutils／butterknife 两种初始化控件方式</li>
  <li>[ ] Android单元测试</li>
  <li>[ ] Android测试工具</li>
  <li>[ ] 图片OOM，Volley源码解读，demo功能实现</li>
  <li>[ ] MVP nucleus简化mvp</li>
  <li>[ ] REST接口</li>
  <li>[ ] Gradle插件</li>
  <li>[ ] 大文件断点上传／下载（上传下载队列）</li>
  <li>[ ] RxJava</li>
  <li>[ ] React开发</li>
  <li>[ ] Android插件话开发</li>
  <li>[ ] Android混淆／加壳儿</li>
  <li>[ ] dragger</li>
  <li>[ ] 增量升级</li>
  <li>[ ] ViewBinding</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
